module generator(mipsIF mif);

	import MIPS_pkg::*;

	// bit [2:0] op_code;
	bit [2:0] rd;
	bit [2:0] rs1;
	bit [2:0] rs2;
	bit [2:0] zeros;

	function REG_gnrt();
		bit [2:0] reg_addr;
		reg_addr = $random;
		return reg_addr;
	endfunction:REG_gnrt
	
	function IMM_gnrt();
		bit [2:0] imm_value;
		imm_value = $random;
		return imm_value;
	endfunction

	// R-Type Instructions
	task NOP_gnrt();
		mif.opcode = NOP;
		mif.rd = REG_gnrt();
		mif.rs1 = REG_gnrt();
		mif.rs2 = REG_gnrt();
		mif.zeros = 3'b000;
	endtask :NOP_gnrt

	task ADD_gnrt();
		mif.opcode = ADD;
		mif.rd = REG_gnrt();
		mif.rs1 = REG_gnrt();
		mif.rs2 = REG_gnrt();
		mif.zeros = 3'b000;
	endtask :ADD_gnrt

	task SUB_gnrt();
		mif.opcode = SUB;
		mif.rd = REG_gnrt();
		mif.rs1 = REG_gnrt();
		mif.rs2 = REG_gnrt();
		mif.zeros = 3'b000;
	endtask:SUB_gnrt

	task AND_gnrt();
		mif.opcode = AND;
		mif.rd = REG_gnrt();
		mif.rs1 = REG_gnrt();
		mif.rs2 = REG_gnrt();
		mif.zeros = 3'b000;
	endtask:AND_gnrt

	task OR_gnrt();
		mif.opcode = OR;
		mif.rd = REG_gnrt();
		mif.rs1 = REG_gnrt();
		mif.rs2 = REG_gnrt();
		mif.zeros = 3'b000;
	endtask:OR_gnrt

	task XOR_gnrt();
		mif.opcode = XOR;
		mif.rd = REG_gnrt();
		mif.rs1 = REG_gnrt();
		mif.rs2 = REG_gnrt();
		mif.zeros = 3'b000;
	endtask:XOR_gnrt

	task SL_gnrt();
		mif.opcode = SL;
		mif.rd = REG_gnrt();
		mif.rs1 = REG_gnrt();
		mif.rs2 = REG_gnrt();
		mif.zeros = 3'b000;
	endtask:SL_gnrt

	task SR_gnrt();
		mif.opcode = SR;
		mif.rd = REG_gnrt();
		mif.rs1 = REG_gnrt();
		mif.rs2 = REG_gnrt();
		mif.zeros = 3'b000;
	endtask:SR_gnrt

	task SRU_gnrt();
		mif.opcode = SRU;
		mif.rd = REG_gnrt();
		mif.rs1 = REG_gnrt();
		mif.rs2 = REG_gnrt();
		mif.zeros = 3'b000;
	endtask:SRU_gnrt

	// I-Type Instructions
	task ADDI_gnrt();
		mif.opcode = ADDI;
		mif.rd = REG_gnrt();
		mif.rs1 = REG_gnrt();
		mif.rs2 = IMM_gnrt();
		mif.zeros = 3'b000;
	endtask : ADDI_gnrt
	
	task LD_gnrt();
		mif.opcode = LD;
		mif.rd = REG_gnrt();	
		mif.rs1 = IMM_gnrt(); // Base address
		mif.rs2 = IMM_gnrt(); // Offset
		mif.zeros = 3'b000;	
	endtask : LD_gnrt
	
	task ST_gnrt();
		mif.opcode = ST;
		mif.rd = REG_gnrt();	
		mif.rs1 = IMM_gnrt(); // Base address
		mif.rs2 = IMM_gnrt(); // Offset
		mif.zeros = 3'b000;	
	endtask : ST_gnrt 
	
	task BZ_gnrt();
		mif.opcode = ST;
		mif.rd = 3'b000;
		mif.rs1 = REG_gnrt();
		mif.rs2 = IMM_gnrt(); // Offset
		mif.zeros = 3'b000;	
	endtask : BZ_gnrt
	
	int f;
	
	always@() 
	begin
		f = $fopen("instructions.txt","w");
		mif.reset();
		repeat(1000)
		begin
			// R-Type
			OR_gnrt();
			// @(posedge mif.clk);
			ADD_gnrt();
			// @(posedge mif.clk);
			SUB_gnrt();
			// @(posedge mif.clk);
			AND_gnrt();
			// @(posedge mif.clk);
			OR_gnrt();
			// @(posedge mif.clk);
			XOR_gnrt();
			// @(posedge mif.clk);
			SL_gnrt();
			// @(posedge mif.clk);
			SR_gnrt();
			// @(posedge mif.clk);
			SRU_gnrt();
			// @(posedge mif.clk);
			// I-Type
			ADDI_gnrt();
			// @(posedge mif.clk);
			LD_gnrt();
			// @(posedge mif.clk);
			ST_gnrt();
			// @(posedge mif.clk);
			BZ_gnrt();
			// @(posedge mif.clk);
			$fwrite(f,"%b\n",{mif.opcode,mif.rd,mif.rs1,mif.rs2,mif.zeros});
		end	
		$fclose(f);
		$stop;
	end

endmodule